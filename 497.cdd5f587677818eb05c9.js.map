{"version":3,"file":"497.cdd5f587677818eb05c9.js","mappings":"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","sources":["webpack://my-portfolio/./src/index.js","webpack://my-portfolio/../pkg/anjin_byte_github_io.js","webpack://my-portfolio/../pkg/anjin_byte_github_io_bg.js"],"sourcesContent":["\"use strict\"\n\nimport \"./styles.css\";\n\nimport * as wasm from \"anjin-byte-github-io\";\nimport { Universe, Cell } from \"anjin-byte-github-io\";\n\n// Import the WebAssembly memory at the top of the file.\nimport { memory } from \"anjin-byte-github-io/anjin_byte_github_io_bg.wasm\";\n\nconst CELL_SIZE = 5; // px\nconst GRID_COLOR = \"#CCCCCC\";\nconst DEAD_COLOR = \"#FFFFFF\";\nconst ALIVE_COLOR = \"#000000\";\n\n// Construct the universe, and get its width and height.\nconst universe = Universe.new();\nconst width = universe.width();\nconst height = universe.height();\n\n\nconst getIndex = (row, column) => {\n    return row * width + column;\n};\n\nconst drawCells = () => {\n    const cellsPtr = universe.cells();\n    const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);\n\n    ctx.beginPath();\n\n    for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n            const idx = getIndex(row, col);\n\n            ctx.fillStyle = cells[idx] === Cell.Dead\n                ? DEAD_COLOR\n                : ALIVE_COLOR;\n\n            ctx.fillRect(\n                col * (CELL_SIZE + 1) + 1,\n                row * (CELL_SIZE + 1) + 1,\n                CELL_SIZE,\n                CELL_SIZE\n            );\n        }\n    }\n\n    ctx.stroke();\n};\n\n\nconst drawGrid = () => {\n    ctx.beginPath();\n    ctx.strokeStyle = GRID_COLOR;\n\n    // Vertical lines.\n    for (let i = 0; i <= width; i++) {\n        ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);\n        ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);\n    }\n\n    // Horizontal lines.\n    for (let j = 0; j <= height; j++) {\n        ctx.moveTo(0, j * (CELL_SIZE + 1) + 1);\n        ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);\n    }\n\n    ctx.stroke();\n};\n\n\n// Give the canvas room for all of our cells and a 1px border\n// around each of them.\nconst canvas = document.getElementById(\"game-of-life-canvas\");\ncanvas.height = (CELL_SIZE + 1) * height + 1;\ncanvas.width = (CELL_SIZE + 1) * width + 1;\n\nconst ctx = canvas.getContext('2d');\n\nconst renderLoop = () => {\n    universe.tick();\n\n    drawGrid();\n    drawCells();\n\n    requestAnimationFrame(renderLoop);\n};\n\nrequestAnimationFrame(renderLoop);","import * as wasm from \"./anjin_byte_github_io_bg.wasm\";\nexport * from \"./anjin_byte_github_io_bg.js\";\nimport { __wbg_set_wasm } from \"./anjin_byte_github_io_bg.js\";\n__wbg_set_wasm(wasm);","let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n/**\n * @param {string} name\n */\nexport function greet(name) {\n    const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.greet(ptr0, len0);\n}\n\nexport const Cell = Object.freeze({ Dead:0,\"0\":\"Dead\",Alive:1,\"1\":\"Alive\", });\n\nconst UniverseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_universe_free(ptr >>> 0, 1));\n\nexport class Universe {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Universe.prototype);\n        obj.__wbg_ptr = ptr;\n        UniverseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        UniverseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_universe_free(ptr, 0);\n    }\n    /**\n     * @returns {Universe}\n     */\n    static new() {\n        const ret = wasm.universe_new();\n        return Universe.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    width() {\n        const ret = wasm.universe_width(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    height() {\n        const ret = wasm.universe_height(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    cells() {\n        const ret = wasm.universe_cells(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {string}\n     */\n    render() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.universe_render(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    tick() {\n        wasm.universe_tick(this.__wbg_ptr);\n    }\n}\n\nexport function __wbg_alert_c3fef96375c34701(arg0, arg1) {\n    alert(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n"],"names":["universe","Universe","width","height","getIndex","row","column","canvas","document","getElementById","ctx","getContext","renderLoop","tick","beginPath","strokeStyle","i","moveTo","lineTo","j","stroke","drawGrid","cellsPtr","cells","Uint8Array","memory","buffer","col","idx","fillStyle","Cell","Dead","fillRect","drawCells","requestAnimationFrame","__wbg_set_wasm","wasm","val","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachedUint8ArrayMemory0","getStringFromWasm0","ptr","len","byteLength","subarray","cachedDataViewMemory0","getDataViewMemory0","detached","undefined","DataView","TextEncoder","encodeInto","Object","freeze","Alive","UniverseFinalization","FinalizationRegistry","register","unregister","__wbg_universe_free","__wrap","obj","create","prototype","__wbg_ptr","__destroy_into_raw","this","free","new","ret","universe_new","universe_width","universe_height","universe_cells","render","deferred1_0","deferred1_1","retptr","__wbindgen_add_to_stack_pointer","universe_render","r0","getInt32","r1","__wbindgen_free","universe_tick","__wbg_alert_c3fef96375c34701","arg0","arg1","alert","__wbindgen_throw","Error"],"sourceRoot":""}